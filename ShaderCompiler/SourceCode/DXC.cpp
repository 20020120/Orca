#include "DXC.h"


#include <cassert>

#include<d3d12shader.h>
#include<dxcapi.h>
#include<iostream>
#include <filesystem>
#include<fstream>

bool ShaderCompiler::DXC::Compile(Microsoft::WRL::ComPtr<IDxcUtils> pUtils_,
    Microsoft::WRL::ComPtr<IDxcCompiler3> pCompiler_, Microsoft::WRL::ComPtr<IDxcIncludeHandler> pIncludeHandler_,
    const wchar_t* FileName_, const wchar_t* Target_, const wchar_t* OutDir_)
{
    // 出力時のファイル名を生成
    std::filesystem::path fileName = FileName_;
    const auto binName = fileName.replace_extension("bin").wstring();
    const auto pdbName = fileName.replace_extension("pdb").wstring();

    //
    // COMMAND LINE:
    // dxc myshader.hlsl -E main -T ps_6_0 -Zi -D MYDEFINE=1 -Fo myshader.bin -Fd myshader.pdb -Qstrip_reflect
    //
    LPCWSTR pszArgs[] =
    {
        FileName_,            // Optional shader source file name for error reporting
        // and for PIX shader source view.  
L"-E", L"main",              // Entry point.
L"-T", Target_,              // Target.
L"-Zs",                      // Enable debug information (slim format)
L"-D", L"MYDEFINE=1",        // A single define.
L"-Fo", binName.c_str(),     // Optional. Stored in the pdb. 
L"-Fd", pdbName.c_str(),     // The file name of the pdb. This must either be supplied
// or the autogenerated file name must be used.
L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
    };


    // ファイルを開く
    Microsoft::WRL::ComPtr < IDxcBlobEncoding> pSource = nullptr;
    pUtils_->LoadFile(FileName_, nullptr, &pSource);
    DxcBuffer Source;
    Source.Ptr = pSource->GetBufferPointer();
    Source.Size = pSource->GetBufferSize();
    Source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.


    // -------------------------------- コンパイルする --------------------------------
    pCompiler_->Compile(
        &Source,                // Source buffer.
        pszArgs,                // Array of pointers to arguments.
        _countof(pszArgs),      // Number of arguments.
        pIncludeHandler_.Get(),        // User-provided interface to handle #include directives (optional).
        IID_PPV_ARGS(mpResults.GetAddressOf()) // Compiler output status, buffer, and errors.
    );

    //
    // Print errors if present.
    //
    Microsoft::WRL::ComPtr < IDxcBlobUtf8> pErrors = nullptr;
    mpResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
    // Note that d3dcompiler would return null if no errors or warnings are present.
    // IDxcCompiler3::Compile will always return an error buffer, but its length
    // will be zero if there are no warnings or errors.
    if (pErrors != nullptr && pErrors->GetStringLength() != 0)
    {
        // エラー
        std::cout << pErrors->GetStringPointer() << std::endl;
        return false;
    }

    //
    // Quit if the compilation failed.
    //
    HRESULT hrStatus;
    mpResults->GetStatus(&hrStatus);
    if (FAILED(hrStatus))
    {
        // エラー
        return false;
    }

    std::filesystem::path outDir = OutDir_;
    // ---------------------------- バイナリとしてシェーダーを保存 ----------------------------
    Microsoft::WRL::ComPtr<IDxcBlob> pShader = nullptr;
    Microsoft::WRL::ComPtr<IDxcBlobUtf16> pShaderName = nullptr;
    mpResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&pShader), &pShaderName);
    if (pShader != nullptr)
    {
        auto outName = outDir.append(fileName.filename().c_str());
        outName.replace_extension("bin");
        std::ofstream fOut;
        fOut.open(outName.c_str(), std::ios::out | std::ios::binary | std::ios::trunc);
        fOut.write(static_cast<const char*>(pShader->GetBufferPointer()), pShader->GetBufferSize());
        fOut.close();
        std::cout << "SUCCESS!!___BinData!!___";
        std::wcout << outName.c_str() << std::endl;
        //FILE* fp = NULL;
        //_wfopen_s(&fp, pShaderName->GetStringPointer(), L"wb");
        //fwrite(pShader->GetBufferPointer(), pShader->GetBufferSize(), 1, fp);
        //fclose(fp);
    }

    // Save pdb
    Microsoft::WRL::ComPtr<IDxcBlob> pPDB = nullptr;
    Microsoft::WRL::ComPtr<IDxcBlobUtf16> pPDBName = nullptr;
    mpResults->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(&pPDB), &pPDBName);
    {
        FILE* fp = NULL;

        // Note that if you don't specify -Fd, a pdb name will be automatically generated.
        // Use this file name to save the pdb so that PIX can find it quickly.
        _wfopen_s(&fp, pPDBName->GetStringPointer(), L"wb");
        fwrite(pPDB->GetBufferPointer(), pPDB->GetBufferSize(), 1, fp);
        fclose(fp);
    }

    //
        // Get separate reflection.
        //
    Microsoft::WRL::ComPtr<IDxcBlob> pReflectionData;
    mpResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&pReflectionData), nullptr);
    if (!pReflectionData)
    {
        return false;
    }
    {
        auto outName = outDir.replace_filename(fileName.filename().c_str());
        outName.replace_extension("ref");
        // リフレクションデータを書き出し
        std::ofstream fOut;
        fOut.open(outName.c_str(), std::ios::out | std::ios::binary | std::ios::trunc);
        fOut.write(static_cast<const char*>(pReflectionData->GetBufferPointer()), pReflectionData->GetBufferSize());
        fOut.close();

        std::cout << "SUCCESS!!___RefData!!___";
        std::wcout << outName.c_str() << std::endl;
    }
    //
   //
   // Print hash.
   //
    Microsoft::WRL::ComPtr<IDxcBlob> pHash = nullptr;
    mpResults->GetOutput(DXC_OUT_SHADER_HASH, IID_PPV_ARGS(&pHash), nullptr);
    if (pHash != nullptr)
    {
        wprintf(L"Hash: ");
        DxcShaderHash* pHashBuf = (DxcShaderHash*)pHash->GetBufferPointer();
        for (int i = 0; i < _countof(pHashBuf->HashDigest); i++)
            wprintf(L"%.2x", pHashBuf->HashDigest[i]);
        wprintf(L"\n");
    }
    return true;
}
